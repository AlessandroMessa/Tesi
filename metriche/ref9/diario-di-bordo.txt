Dopo aver risolto i cicli con maggiore impatto, sono rimasti tre casi di Cyclic Dependency a basso impatto e severit√†. Essendo analoghi nella struttura e nel refactoring richiesto, sono stati affrontati con una singola iterazione semplificata, mediante tecniche standard come il Move Class e l‚Äôintroduzione di interfacce, al fine di eliminare i legami circolari residui.

Rifattoring degli ultimi due Cyclic Dependency Smells
‚úÖ 2. Ciclo tra com.ruoyi.job.service e com.ruoyi.job.util
üîç Problema rilevato
Il package job.util conteneva classi come AbstractQuartzJob, che facevano uso diretto di ISysJobLogService, generando un ciclo:

Copia codice
job.util ‚Üí job.service ‚Üí job.util
üõ†Ô∏è Soluzione applicata
√à stato spostato AbstractQuartzJob (e le sue sottoclassi) da util a un nuovo package:

Copia codice
com.ruoyi.job.execution
Il package util √® stato riorganizzato in sottopacchetti pi√π specifici (util.cron, util.invoke, ecc.), mantenendolo unidirezionale rispetto agli altri layer.

‚úÖ Risultato
Il ciclo √® stato rimosso

La semantica architetturale √® migliorata grazie alla chiara separazione tra utility e logica esecutiva

‚úÖ 3. Ciclo triangolare nel modulo Gateway: config ‚Üî handler ‚Üî service
üîç Problema rilevato
Nel modulo ruoyi-gateway era presente un ciclo tra:

scss
Copia codice
RouterFunctionConfiguration (config)
‚Üí ValidateCodeHandler (handler)
‚Üí ValidateCodeServiceImpl (service)
‚Üí CaptchaProperties (config)
üõ†Ô∏è Soluzioni applicate
√à stato creato un nuovo package modulare:

Copia codice
com.ruoyi.gateway.captcha
contenente:

captcha.config: CaptchaProperties, CaptchaConfig

captcha.service, captcha.service.impl

captcha.handler

captcha.filter

captcha.support: KaptchaTextCreator

Le dipendenze sono state rese unidirezionali:

RouterFunctionConfiguration dipende da ValidateCodeHandler

CaptchaProperties √® stato isolato in un package dedicato al dominio captcha

‚úÖ Risultato
Il ciclo architetturale √® stato spezzato

Il modulo Captcha √® diventato modulare, coeso e isolato

Gateway config non √® pi√π accoppiato con service o handler

üß± Considerazioni architetturali: Captcha come microservizio
Grazie alla riorganizzazione modulare di Captcha, √® ora architetturalmente possibile estrarlo come microservizio autonomo, perch√©:

üìå Motivi che giustificano l‚Äôestrazione:
Criterio	Stato attuale del modulo captcha
Isolabilit√† funzionale	Tutte le classi sono nel package captcha
Dipendenze esterne minime	Nessuna dipendenza verso altri moduli gateway
Routing gi√† definito	L‚Äôendpoint /code pu√≤ diventare remoto
Configurazione dedicata	CaptchaProperties √® separato dal resto
Riutilizzabilit√†	Potrebbe servire anche ad app mobile, altri front-end

üß© Estrarlo in futuro significherebbe:
Spostare tutto il package com.ruoyi.gateway.captcha in un nuovo microservizio ruoyi-captcha-service

Esporre un'API REST (es. POST /api/captcha/verify, GET /api/captcha/image)

Chiamare quel microservizio dal Gateway tramite HTTP o load-balanced FeignClient

‚úçÔ∏è Testo suggerito per la tesi
Dopo la riorganizzazione modulare della logica Captcha, il dominio funzionale √® stato isolato all'interno di un package dedicato, strutturato secondo un approccio feature-based. Tale refactoring non solo ha permesso di eliminare una Cyclic Dependency architetturale, ma ha anche portato il modulo Captcha a un elevato livello di coesione e autonomia.
Di conseguenza, si apre la possibilit√† di evolvere questa funzionalit√† in un microservizio indipendente, che potrebbe essere esposto tramite API REST e consumato dal Gateway o da altri client, favorendo cos√¨ una futura scalabilit√† del sistema.

L'ultimo cyclic dependency rilevato da Arcan √® stato quello tra l'annotazione custom @Xss e il validatore XssValidator. Tale ciclo √® una conseguenza diretta dell'utilizzo del framework Bean Validation (JSR 380), che impone questa relazione bidirezionale tra annotazioni e validatori. In questo caso, pur essendo architettonicamente un ciclo, il refactoring risulterebbe eccessivo e artificioso rispetto al beneficio ottenuto.
Si √® quindi scelto di accettare e documentare questo ciclo, considerandolo un trade-off consapevole, coerente con il funzionamento del framework. Inoltre, il technical debt associato era basso (TD = 7), confermando la scarsa priorit√† di intervento.